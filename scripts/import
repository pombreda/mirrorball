#!/usr/bin/python
#
# Copyright (c) 2008-2009 rPath, Inc.
#
# This program is distributed under the terms of the Common Public License,
# version 1.0. A copy of this license should have been distributed with this
# source file in a file called LICENSE. If it is not present, the license
# is always available at http://www.rpath.com/permanent/licenses/CPL-1.0.
#
# This program is distributed in the hope that it will be useful, but
# without any warranty; without even the implied warranty of merchantability
# or fitness for a particular purpose. See the Common Public License for
# full details.
#

import os
import sys
import itertools

sys.path.insert(0, os.path.abspath('../'))

from conary.lib import util
sys.excepthook = util.genExcepthook()

from updatebot import bot, config, log

log.addRootLogger()
cfg = config.UpdateBotConfig()
cfg.read(os.path.abspath('../') + '/config/%s/updatebotrc' % sys.argv[1])
obj = bot.Bot(cfg)

# load the package source
pkgSource = obj._pkgSource
pkgSource.load()

# filter out sources we don't know how to deal with yet.
names = {}
srcNevras = {}
removed = {}
removedNames = set()
for src, bins in pkgSource.srcPkgMap.iteritems():
    # a source without any binaries
    if len(bins) <= 1:
        continue

    # filter out packages that we don't handle right now.
    if (src.name in removedNames): #or
        ## the kernel needs a recipe
        #'kernel' in src.name):

        removed.setdefault(src.getNevra(), src)
        removedNames.add(src.name)
        continue

    names.setdefault(src.name, set()).add(src.getNevra())
    srcNevras.setdefault(src.getNevra(), src)

for nevra in itertools.chain(*[ x for x in names.values() if len(x) > 1 ]):
    removed.setdefault(nevra, srcNevras.pop(nevra))

toCreate = set(srcNevras.values())

trvMap, failures = obj.create(toCreate=toCreate, recreate=True)

import epdb ; epdb.st()

for job in trvMap:
    for source in sorted(job):
        for bin in job[source]:
            if ':' not in bin[0]:
                print '%s=%s[%s]' % bin
