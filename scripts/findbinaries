#!/usr/bin/python
#
# Copyright (c) rPath, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import os
import sys

mirrorballDir = os.path.abspath('../')
sys.path.insert(0, mirrorballDir)

from conary.lib import util
sys.excepthook = util.genExcepthook()

import copy
import logging

from updatebot import log
from updatebot import bot
from updatebot import errors
from updatebot import config
from updatebot import conaryhelper

log.addRootLogger()

slog = logging.getLogger('findbinaries')

cfg = config.UpdateBotConfig()
cfg.read(mirrorballDir + '/config/%s/updatebotrc' % sys.argv[1])

bot = bot.Bot(cfg)
updater = bot._updater
helper = updater._conaryhelper

def filterPkgs(collection):
    def fltr(name):
        if type(name) == tuple:
            name = name[0]

        if (name.split(':')[0] in cfg.excludePackages or
            name.startswith('info-') or
            name.startswith('factory-') or
            name.startswith('group-')):
            return True
        return False

    newCollection = copy.deepcopy(collection)
    for item in collection:
        if not fltr(item):
            continue
        if type(collection) == dict:
            del newCollection[item]
        else:
            newCollection.remove(item)

    return newCollection


pkgs = helper._repos.getTroveLeavesByLabel({None: {helper._ccfg.buildLabel: None}})

try:
    groupPkgs = helper.getSourceTroves(cfg.topGroup)
except errors.GroupNotFound:
    groupPkgs = {}

pkgs = filterPkgs(pkgs)
groupPkgs = filterPkgs(groupPkgs)

pkgSet = set([ x.split(':')[0] for x in pkgs ])

# remove versions and flavors from groupPkgs
grpPkgs = {}
for key, value in groupPkgs.iteritems():
    key = key[0].split(':')[0]
    if key not in grpPkgs:
        grpPkgs[key] = set()

    for item in value:
        grpPkgs[key].add(item[0])

# Build of map of the latest versions of all src:set([binary, ...]) that are
# on the buildLabel.
srcDict = {}
for pkg in pkgSet:
    # This is normally due to unbuilt sources.
    if pkg not in pkgs:
        slog.warn('skipping %s' % pkg)
        continue

    version = pkgs[pkg].keys()[0]
    flavors = pkgs[pkg][version]
    if len(flavors) == 0:
        flavor = None
    else:
        flavor = flavors[0]

    slog.info('getting binaries for %s' % pkg)
    for src, binSet in helper._getSourceTroves((pkg, version, flavor)).iteritems():
        src = (src[0].split(':')[0], src[1], src[2])
        if src not in srcDict:
            srcDict[src] = set()

        for bin in binSet:
            name = bin[0].split(':')[0]
            srcDict[src].add((name, bin[1], bin[2]))

srcNameDict = {}
for src, binSet in srcDict.iteritems():
    latest = None
    for bin in binSet:
        if not latest:
            latest = bin[1]

        if bin[1] > latest:
            latest = bin[1]

    if src[0] not in srcNameDict:
        srcNameDict[src[0]] = set()

    for bin in binSet:
        if bin[1] == latest:
            srcNameDict[src[0]].add(bin[0])


# Now that we have a mapping of source trove name to set of binary trove names
# find the sources and binaries that are not included in the group.
newPkgs = {}
for srcName in srcNameDict:
    if srcName not in grpPkgs:
        newPkgs[srcName] = srcNameDict[srcName]
    else:
        newPkgs[srcName] = srcNameDict[srcName].difference(grpPkgs[srcName])

# Flatten the newPkgs dict to a list of binaries
bins = set()
for value in newPkgs.itervalues():
    bins.update(value)

binLst = list(bins)
binLst.sort()

for item in binLst:
    print ' ' * 11, '\'%s\',' % item
